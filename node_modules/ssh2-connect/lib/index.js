// Generated by CoffeeScript 2.0.2
// # Connect

// This module provide a callback based api to open an ssh2 connection.

// For example, the original ssh2 code...   

// ```coffee
// ssh2 = require 'ssh2'
// connection = new ssh2()
// connection.on 'error', (err) ->
//   connection.end()
//   # not ready at all
// connection.on 'ready', ->
//   # ready to go
// connection.connect options
// ```

// ...is simplified to:   

// ```coffee
// connect = require 'ssh2-exec/lib/connect'
// connect options, (err, ssh) ->
//   # this is faster to write
// ```
var camelize, fs, ssh2;

fs = require('fs');

ssh2 = require('ssh2');

// Options are inherited from the [ssh2 `Connection.prototype.connect`][ssh2-connect]
// function with a few additions:

// -   `username`   
//     The username used to initiate the connection, default to the current
//     environment user.
// -   `privateKeyPath`   
//     Path to the file containing the private key.   
// -   `retry`
//     Attempt to reconnect multiple times, default to "1".   
// -   `wait`
//     Time to wait in milliseconds between each retry, default to "500".     

// Note, the "privateKeyPath" option is provided as a conveniency to  prepare the 
// "privateKey" property.

// Additionally, all options may be provided in camalize (the default in [ssh2]) or
// underscore form. For example, both "privateKey" and "private_key" would be
// interprated the same.
module.exports = function(options, callback) {
  var connect, match, privateKeyPath, retry, st;
  if (options instanceof ssh2) {
    return callback(null, options);
  }
  options = camelize(options);
  if (options.username == null) {
    options.username = process.env['USER'] || require('child_process').execSync("whoami", {
      encoding: 'utf8',
      timeout: 1000
    }).trim();
  }
  if (options.username == null) {
    options.username = 'root'; // We've seed 'USER' not inside env inside the docker centos6 container.
  }
  if (options.retry == null) {
    options.retry = 1;
  }
  if (!options.password && !options.privateKey) {
    if (options.privateKeyPath == null) {
      options.privateKeyPath = '~/.ssh/id_rsa';
    }
    if (options.privateKeyPath && (match = /~(\/.*)/.exec(options.privateKeyPath))) {
      options.privateKeyPath = process.env.HOME + match[1];
    }
  } else {
    options.privateKeyPath = null;
  }
  privateKeyPath = function() {
    if (!options.privateKeyPath) {
      return connect();
    }
    return fs.readFile(options.privateKeyPath, 'ascii', function(err, privateKey) {
      options.privateKey = privateKey;
      return connect();
    });
  };
  retry = options.retry;
  st = Date.now();
  connect = function() {
    var connection, succeed;
    if (retry !== true && retry > 0) {
      retry--;
    }
    succeed = false;
    connection = new ssh2();
    connection.on('error', function(err) {
      connection.end();
      // Event "error" is thrown after a "ready" if the connection is lost
      if (succeed) {
        return;
      }
      if (retry === true || retry > 0) {
        return setTimeout(connect, 2000);
      } else {
        return callback(err);
      }
    });
    connection.on('ready', function() {
      succeed = true;
      return callback(null, connection);
    });
    return connection.connect(options);
  };
  return privateKeyPath();
};

camelize = function(obj) {
  var k, newk, v;
  for (k in obj) {
    v = obj[k];
    newk = k.replace(/[_.-](\w|$)/g, function(_, x) {
      return x.toUpperCase();
    });
    if (k !== newk) {
      obj[newk] = v;
    }
  }
  return obj;
};

// [ssh2]: https://github.com/mscdex/ssh2
// [ssh2-connect]: https://github.com/wdavidw/node-ssh2-connect
